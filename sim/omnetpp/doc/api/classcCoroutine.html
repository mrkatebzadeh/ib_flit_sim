<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>OMNeT++ Simulation Library: cCoroutine Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cCoroutine Class Reference<br>
<small>
[<a class="el" href="group__Internals.html">Internal classes</a>]</small>
</h1><!-- doxytag: class="cCoroutine" --><code>#include &lt;<a class="el" href="ccoroutine_8h-source.html">ccoroutine.h</a>&gt;</code>
<p>

<p>
<a href="classcCoroutine-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Low-level coroutine library. 
<p>
Coroutines are used by <a class="el" href="classcSimpleModule.html" title="Base class for all simple module classes.">cSimpleModule</a>.<p>
<a class="el" href="classcCoroutine.html" title="Low-level coroutine library.">cCoroutine</a> has platform-dependent implementation:<p>
On Windows, it uses the Win32 Fiber API.<p>
On Unix-like systems, it uses POSIX coroutines (setcontext()/switchcontext()) if they are available.<p>
Otherwise, it uses a portable coroutine library first described by Stig Kofoed ("Portable coroutines", see the Manual for a better reference). It creates all coroutine stacks within the main stack, and uses setjmp()/longjmp() for context switching. This implies that the maximum stack space allowed by the operating system for the OMNeT++ process must be sufficiently high (several, maybe several hundred megabytes), otherwise a segmentation fault will occur. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor, destructor</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#a28d47689379f53aada0130ddf07bb4a">setup</a> (<a class="el" href="group__EnumsTypes.html#g5082fb55ece1f2bcc5f8c363940fdd51">CoroutineFnp</a> fnp, void *arg, unsigned stack_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#03978af1f95966a51d3a09a1446fd863">cCoroutine</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#e66f141d8beb3fffb207dba791d02c0e">~cCoroutine</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Coroutine statistics</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#d9ca3ee1464887f1c5110049e3223724">hasStackOverflow</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#e62aba6c90f2f5d567b7ad3ab0723430">getStackSize</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#688104a83d103cd8e4c5940dead58ade">getStackUsage</a> () const </td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Coroutine control</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#8362bdfd9b2744f9737b0a2a8b869b22">init</a> (unsigned total_stack, unsigned main_stack)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#51453982a5de8246527593b960dbcb6c">switchTo</a> (<a class="el" href="classcCoroutine.html">cCoroutine</a> *cor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcCoroutine.html#9499edcba31be69a71dbe33ea22815c1">switchToMain</a> ()</td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="03978af1f95966a51d3a09a1446fd863"></a><!-- doxytag: member="cCoroutine::cCoroutine" ref="03978af1f95966a51d3a09a1446fd863" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cCoroutine::cCoroutine           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="e66f141d8beb3fffb207dba791d02c0e"></a><!-- doxytag: member="cCoroutine::~cCoroutine" ref="e66f141d8beb3fffb207dba791d02c0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual cCoroutine::~cCoroutine           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8362bdfd9b2744f9737b0a2a8b869b22"></a><!-- doxytag: member="cCoroutine::init" ref="8362bdfd9b2744f9737b0a2a8b869b22" args="(unsigned total_stack, unsigned main_stack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cCoroutine::init           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>total_stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>main_stack</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the coroutine library. 
<p>
This function has to be called exactly once in a program, possibly at the top of main(). 
</div>
</div><p>
<a class="anchor" name="51453982a5de8246527593b960dbcb6c"></a><!-- doxytag: member="cCoroutine::switchTo" ref="51453982a5de8246527593b960dbcb6c" args="(cCoroutine *cor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cCoroutine::switchTo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcCoroutine.html">cCoroutine</a> *&nbsp;</td>
          <td class="paramname"> <em>cor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Switch to another coroutine. 
<p>
The execution of the current coroutine is suspended and the other coroutine is resumed from the point it last left off. 
</div>
</div><p>
<a class="anchor" name="9499edcba31be69a71dbe33ea22815c1"></a><!-- doxytag: member="cCoroutine::switchToMain" ref="9499edcba31be69a71dbe33ea22815c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cCoroutine::switchToMain           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Switch to the main coroutine (the one main() runs in). 
<p>

</div>
</div><p>
<a class="anchor" name="a28d47689379f53aada0130ddf07bb4a"></a><!-- doxytag: member="cCoroutine::setup" ref="a28d47689379f53aada0130ddf07bb4a" args="(CoroutineFnp fnp, void *arg, unsigned stack_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cCoroutine::setup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__EnumsTypes.html#g5082fb55ece1f2bcc5f8c363940fdd51">CoroutineFnp</a>&nbsp;</td>
          <td class="paramname"> <em>fnp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>stack_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets up a coroutine. 
<p>
The arguments are the function that should be run in the coroutine, a pointer that is passed to the coroutine function, and the stack size. 
</div>
</div><p>
<a class="anchor" name="d9ca3ee1464887f1c5110049e3223724"></a><!-- doxytag: member="cCoroutine::hasStackOverflow" ref="d9ca3ee1464887f1c5110049e3223724" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cCoroutine::hasStackOverflow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if there was a stack overflow during execution of the coroutine. 
<p>
Windows/Fiber API, POSIX coroutines: Not implemented: always returns false.<p>
Portable coroutines: it checks the intactness of a predefined byte pattern (0xdeadbeef) at the stack boundary, and report stack overflow if it was overwritten. The mechanism usually works fine, but occasionally it can be fooled by large uninitialized local variables (e.g. char buffer[256]): if the byte pattern happens to fall in the middle of such a local variable, it may be preserved intact and stack violation is not detected. 
</div>
</div><p>
<a class="anchor" name="e62aba6c90f2f5d567b7ad3ab0723430"></a><!-- doxytag: member="cCoroutine::getStackSize" ref="e62aba6c90f2f5d567b7ad3ab0723430" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned cCoroutine::getStackSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the stack size of the coroutine. 
<p>

</div>
</div><p>
<a class="anchor" name="688104a83d103cd8e4c5940dead58ade"></a><!-- doxytag: member="cCoroutine::getStackUsage" ref="688104a83d103cd8e4c5940dead58ade" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned cCoroutine::getStackUsage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the amount of stack actually used by the coroutine. 
<p>
Windows/Fiber API, POSIX coroutines: Not implemented, always returns 0.<p>
Portable coroutines: It works by checking the intactness of predefined byte patterns (0xdeadbeef) placed in the stack. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ccoroutine_8h-source.html">ccoroutine.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Mar 27 11:22:11 2012 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
