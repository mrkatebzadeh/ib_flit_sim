<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>OMNeT++ Simulation Library: cTopology Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cTopology Class Reference<br>
<small>
[<a class="el" href="group__SimSupport.html">Utility classes</a>]</small>
</h1><!-- doxytag: class="cTopology" --><!-- doxytag: inherits="cOwnedObject" --><code>#include &lt;<a class="el" href="ctopology_8h-source.html">ctopology.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for cTopology:</div>
<div class="dynsection">

<p><center><img src="classcTopology.png" usemap="#cTopology_map" border="0" alt=""></center>
<map name="cTopology_map">
<area href="classcOwnedObject.html" alt="cOwnedObject" shape="rect" coords="0,112,96,136">
<area href="classcNamedObject.html" alt="cNamedObject" shape="rect" coords="0,56,96,80">
<area href="classcObject.html" alt="cObject" shape="rect" coords="0,0,96,24">
</map>
</div>

<p>
<a href="classcTopology-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Routing support. 
<p>
The <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a> class was designed primarily to support routing in telecommunication or multiprocessor networks.<p>
A <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a> object stores an abstract representation of the network in graph form: <ul>
<li>
each <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a> node corresponds to a module (simple or compound), and </li>
<li>
each <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a> edge corresponds to a link or series of connecting links. </li>
</ul>
<p>
You can specify which modules (either simple or compound) you want to include in the graph. The graph will include all connections among the selected modules. In the graph, all nodes are at the same level, there is no submodule nesting. Connections which span across compound module boundaries are also represented as one graph edge. Graph edges are directed, just as module gates are.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcTopology_1_1Node.html" title="Supporting class for cTopology, represents a node in the graph.">cTopology::Node</a>, <a class="el" href="classcTopology_1_1Link.html" title="Supporting class for cTopology, represents a link in the graph.">cTopology::Link</a>, <a class="el" href="classcTopology_1_1LinkIn.html" title="Supporting class for cTopology.">cTopology::LinkIn</a>, <a class="el" href="classcTopology_1_1LinkOut.html" title="Supporting class for cTopology.">cTopology::LinkOut</a> </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor, assignment</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#a540fd27dcbbd67714c1eb46980c049d">cTopology</a> (const char *name=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#6b4430e9e3a4b3ffe346d8dc85e29987">cTopology</a> (const <a class="el" href="classcTopology.html">cTopology</a> &amp;topo)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#97436f45bc7fc20ba3802d11a4cfe173">~cTopology</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcTopology.html">cTopology</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#f9ebab8c0519c82df3f3e358ffd035b2">operator=</a> (const <a class="el" href="classcTopology.html">cTopology</a> &amp;topo)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Redefined cObject member functions.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcTopology.html">cTopology</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#f9fb1215e25675e3f49ada50acae1605">dup</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#644049ca8239eb389fe20a49e3d3c428">info</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#790b08ba3baa3a66808e5f72525f52d9">parsimPack</a> (<a class="el" href="classcCommBuffer.html">cCommBuffer</a> *buffer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#40a84d778bad4bf009bfe6a7661fc33c">parsimUnpack</a> (<a class="el" href="classcCommBuffer.html">cCommBuffer</a> *buffer)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Extracting the topology from a network.</div></td></tr>
<tr><td colspan="2"><div class="groupText">extract.<p>
..() functions build topology from the model. User can select which modules to include. All connections between those modules will be in the topology. Connections can cross compound module boundaries. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#449b5ad0c2916511e76d7b0131a6ef09">extractFromNetwork</a> (bool(*selfunc)(<a class="el" href="classcModule.html">cModule</a> *, void *), void *userdata=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#688e0515aa814e872564cfb122c87d85">extractFromNetwork</a> (<a class="el" href="classcTopology_1_1Predicate.html">Predicate</a> *predicate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#54b4891abd28e1a9700946654034d367">extractByModulePath</a> (const std::vector&lt; std::string &gt; &amp;fullPathPatterns)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#e2b6970c74322b7179e136029a187f9c">extractByNedTypeName</a> (const std::vector&lt; std::string &gt; &amp;nedTypeNames)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#387ea85304d459e6da463fea8aeb7f72">extractByProperty</a> (const char *propertyName, const char *value=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#5a5f9bd454fb850d158640e4f8c7cd0c">extractByParameter</a> (const char *paramName, const char *paramValue=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#7d96a698039156fb857a9ba72a41379c">clear</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Functions to examine topology by hand.</div></td></tr>
<tr><td colspan="2"><div class="groupText">Users also need to rely on Node and Link member functions to explore the graph stored in the object. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#9ab37e112ec07e7cdded2c5046910957">getNumNodes</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#90e795af4b961529b8e2d83eca316079">getNode</a> (int i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#4000b9e28b62b3c1816d69695d93da95">getNodeFor</a> (<a class="el" href="classcModule.html">cModule</a> *mod)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Algorithms to find shortest paths.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#cac27e130259f6992b726d31cc9f10fd">calculateUnweightedSingleShortestPathsTo</a> (<a class="el" href="classcTopology_1_1Node.html">Node</a> *target)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology.html#78dbad0c81c4242b6aa4584c1b47f6cb">getTargetNode</a> () const </td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1Link.html">Link</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting class for <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a>, represents a link in the graph.  <a href="classcTopology_1_1Link.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1LinkIn.html">LinkIn</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting class for <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a>.  <a href="classcTopology_1_1LinkIn.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1LinkOut.html">LinkOut</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting class for <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a>.  <a href="classcTopology_1_1LinkOut.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1Node.html">Node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Supporting class for <a class="el" href="classcTopology.html" title="Routing support.">cTopology</a>, represents a node in the graph.  <a href="classcTopology_1_1Node.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcTopology_1_1Predicate.html">Predicate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for selector objects used in extract.  <a href="classcTopology_1_1Predicate.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a540fd27dcbbd67714c1eb46980c049d"></a><!-- doxytag: member="cTopology::cTopology" ref="a540fd27dcbbd67714c1eb46980c049d" args="(const char *name=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cTopology::cTopology           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="6b4430e9e3a4b3ffe346d8dc85e29987"></a><!-- doxytag: member="cTopology::cTopology" ref="6b4430e9e3a4b3ffe346d8dc85e29987" args="(const cTopology &amp;topo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cTopology::cTopology           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcTopology.html">cTopology</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>topo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="97436f45bc7fc20ba3802d11a4cfe173"></a><!-- doxytag: member="cTopology::~cTopology" ref="97436f45bc7fc20ba3802d11a4cfe173" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual cTopology::~cTopology           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f9ebab8c0519c82df3f3e358ffd035b2"></a><!-- doxytag: member="cTopology::operator=" ref="f9ebab8c0519c82df3f3e358ffd035b2" args="(const cTopology &amp;topo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcTopology.html">cTopology</a>&amp; cTopology::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcTopology.html">cTopology</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>topo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. 
<p>
The name member is not copied; see cNamedObject's <a class="el" href="classcTopology.html#f9ebab8c0519c82df3f3e358ffd035b2" title="Assignment operator.">operator=()</a> for more details. 
</div>
</div><p>
<a class="anchor" name="f9fb1215e25675e3f49ada50acae1605"></a><!-- doxytag: member="cTopology::dup" ref="f9fb1215e25675e3f49ada50acae1605" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcTopology.html">cTopology</a>* cTopology::dup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates and returns an exact copy of this object. 
<p>
See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. 
<p>Reimplemented from <a class="el" href="classcObject.html#a5c41ae00a77e27af6c7b52d3b63669a">cObject</a>.</p>

</div>
</div><p>
<a class="anchor" name="644049ca8239eb389fe20a49e3d3c428"></a><!-- doxytag: member="cTopology::info" ref="644049ca8239eb389fe20a49e3d3c428" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cTopology::info           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Produces a one-line description of the object's contents. 
<p>
See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. 
<p>Reimplemented from <a class="el" href="classcObject.html#28c24b5dcb3703c5f6ae92a67bd61c31">cObject</a>.</p>

</div>
</div><p>
<a class="anchor" name="790b08ba3baa3a66808e5f72525f52d9"></a><!-- doxytag: member="cTopology::parsimPack" ref="790b08ba3baa3a66808e5f72525f52d9" args="(cCommBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cTopology::parsimPack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcCommBuffer.html">cCommBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serializes the object into an MPI send buffer. 
<p>
Used by the simulation kernel for parallel execution. See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. 
<p>Reimplemented from <a class="el" href="classcOwnedObject.html#56c49bc9247353a2bb722f6ffa8ba287">cOwnedObject</a>.</p>

</div>
</div><p>
<a class="anchor" name="40a84d778bad4bf009bfe6a7661fc33c"></a><!-- doxytag: member="cTopology::parsimUnpack" ref="40a84d778bad4bf009bfe6a7661fc33c" args="(cCommBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cTopology::parsimUnpack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcCommBuffer.html">cCommBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deserializes the object from an MPI receive buffer Used by the simulation kernel for parallel execution. 
<p>
See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. 
<p>Reimplemented from <a class="el" href="classcOwnedObject.html#99ab774a7da23edf9d9f9ac96a066637">cOwnedObject</a>.</p>

</div>
</div><p>
<a class="anchor" name="449b5ad0c2916511e76d7b0131a6ef09"></a><!-- doxytag: member="cTopology::extractFromNetwork" ref="449b5ad0c2916511e76d7b0131a6ef09" args="(bool(*selfunc)(cModule *, void *), void *userdata=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractFromNetwork           </td>
          <td>(</td>
          <td class="paramtype">bool(*)(<a class="el" href="classcModule.html">cModule</a> *, void *)&nbsp;</td>
          <td class="paramname"> <em>selfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts model topology by a user-defined criteria. 
<p>
Includes into the graph modules for which the passed selfunc() returns nonzero. The userdata parameter may take any value you like, and it is passed back to selfunc() in its second argument. 
</div>
</div><p>
<a class="anchor" name="688e0515aa814e872564cfb122c87d85"></a><!-- doxytag: member="cTopology::extractFromNetwork" ref="688e0515aa814e872564cfb122c87d85" args="(Predicate *predicate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractFromNetwork           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcTopology_1_1Predicate.html">Predicate</a> *&nbsp;</td>
          <td class="paramname"> <em>predicate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type safe, object-oriented equivalent of extractFromNetwork(selfunc, userdata). 
<p>

</div>
</div><p>
<a class="anchor" name="54b4891abd28e1a9700946654034d367"></a><!-- doxytag: member="cTopology::extractByModulePath" ref="54b4891abd28e1a9700946654034d367" args="(const std::vector&lt; std::string &gt; &amp;fullPathPatterns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractByModulePath           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>fullPathPatterns</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts model topology by module full path. 
<p>
All modules whole <a class="el" href="classcObject.html#26c918d8176ea1ce3bc6b87cc7e45464" title="Returns the full path of the object in the object hierarchy, like &quot;net.host[2]...">getFullPath()</a> matches one of the patterns in given string vector will get included. The patterns may contain wilcards in the same syntax as in ini files.<p>
An example:<p>
<code>topo.extractByModulePath(<a class="el" href="classcStringTokenizer.html" title="String tokenizer class, modelled after strtok().">cStringTokenizer</a>("**.host[*] **.router*").asVector());</code> 
</div>
</div><p>
<a class="anchor" name="e2b6970c74322b7179e136029a187f9c"></a><!-- doxytag: member="cTopology::extractByNedTypeName" ref="e2b6970c74322b7179e136029a187f9c" args="(const std::vector&lt; std::string &gt; &amp;nedTypeNames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractByNedTypeName           </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>nedTypeNames</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts model topology by the fully qualified NED type name of the modules. 
<p>
All modules whose getNedTypeName() is listed in the given string vector will get included.<p>
Note: If you have all class names as a single, space-separated string, you can use <a class="el" href="classcStringTokenizer.html" title="String tokenizer class, modelled after strtok().">cStringTokenizer</a> to turn it into a string vector:<p>
<code>topo.extractByNedTypeName(<a class="el" href="classcStringTokenizer.html" title="String tokenizer class, modelled after strtok().">cStringTokenizer</a>("some.package.Host other.package.Router").asVector());</code> 
</div>
</div><p>
<a class="anchor" name="387ea85304d459e6da463fea8aeb7f72"></a><!-- doxytag: member="cTopology::extractByProperty" ref="387ea85304d459e6da463fea8aeb7f72" args="(const char *propertyName, const char *value=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractByProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts model topology by a module property. 
<p>
All modules get included that have a property with the given name and the given value (more precisely, the first value of its default key being the specified value). If value is NULL, the property's value may be anything except "false" (i.e. the first value of the default key may not be "false").<p>
For example, <code>topo.extractByProperty("node");</code> would extract all modules that contain the <code>@node</code> property, like the following one:<p>
<pre>
 module X {
     @node;
 }
 </pre> 
</div>
</div><p>
<a class="anchor" name="5a5f9bd454fb850d158640e4f8c7cd0c"></a><!-- doxytag: member="cTopology::extractByParameter" ref="5a5f9bd454fb850d158640e4f8c7cd0c" args="(const char *paramName, const char *paramValue=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::extractByParameter           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>paramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>paramValue</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extracts model topology by a module parameter. 
<p>
All modules get included that have a parameter with the given name, and the parameter's str() method returns the paramValue string. If paramValue is NULL, only the parameter's existence is checked but not its value. 
</div>
</div><p>
<a class="anchor" name="7d96a698039156fb857a9ba72a41379c"></a><!-- doxytag: member="cTopology::clear" ref="7d96a698039156fb857a9ba72a41379c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the topology stored in the object. 
<p>

</div>
</div><p>
<a class="anchor" name="9ab37e112ec07e7cdded2c5046910957"></a><!-- doxytag: member="cTopology::getNumNodes" ref="9ab37e112ec07e7cdded2c5046910957" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cTopology::getNumNodes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of nodes in the graph. 
<p>

</div>
</div><p>
<a class="anchor" name="90e795af4b961529b8e2d83eca316079"></a><!-- doxytag: member="cTopology::getNode" ref="90e795af4b961529b8e2d83eca316079" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcTopology_1_1Node.html">Node</a>* cTopology::getNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns pointer to the ith node in the graph. 
<p>
Node's methods can be used to further examine the node's connectivity, etc. 
</div>
</div><p>
<a class="anchor" name="4000b9e28b62b3c1816d69695d93da95"></a><!-- doxytag: member="cTopology::getNodeFor" ref="4000b9e28b62b3c1816d69695d93da95" args="(cModule *mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcTopology_1_1Node.html">Node</a>* cTopology::getNodeFor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the graph node which corresponds to the given module in the network. 
<p>
If no graph node corresponds to the module, the method returns NULL. This method assumes that the topology corresponds to the network, that is, it was probably created with one of the extract...() functions. 
</div>
</div><p>
<a class="anchor" name="cac27e130259f6992b726d31cc9f10fd"></a><!-- doxytag: member="cTopology::calculateUnweightedSingleShortestPathsTo" ref="cac27e130259f6992b726d31cc9f10fd" args="(Node *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cTopology::calculateUnweightedSingleShortestPathsTo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcTopology_1_1Node.html">Node</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply the Dijkstra algorithm to find all shortest paths to the given graph node. 
<p>
The paths found can be extracted via Node's methods. 
</div>
</div><p>
<a class="anchor" name="78dbad0c81c4242b6aa4584c1b47f6cb"></a><!-- doxytag: member="cTopology::getTargetNode" ref="78dbad0c81c4242b6aa4584c1b47f6cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcTopology_1_1Node.html">Node</a>* cTopology::getTargetNode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the node that was passed to the most recently called shortest path finding function. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ctopology_8h-source.html">ctopology.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Mar 27 11:22:13 2012 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
