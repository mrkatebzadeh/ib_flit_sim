<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>OMNeT++ Simulation Library: cSimpleModule Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cSimpleModule Class Reference<br>
<small>
[<a class="el" href="group__SimCore.html">Simulation core classes</a>]</small>
</h1><!-- doxytag: class="cSimpleModule" --><!-- doxytag: inherits="cModule" --><code>#include &lt;<a class="el" href="csimplemodule_8h-source.html">csimplemodule.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for cSimpleModule:</div>
<div class="dynsection">

<p><center><img src="classcSimpleModule.png" usemap="#cSimpleModule_map" border="0" alt=""></center>
<map name="cSimpleModule_map">
<area href="classcModule.html" alt="cModule" shape="rect" coords="90,336,261,360">
<area href="classcComponent.html" alt="cComponent" shape="rect" coords="90,280,261,304">
<area href="classcDefaultList.html" alt="cDefaultList" shape="rect" coords="90,224,261,248">
<area href="classcNoncopyableOwnedObject.html" alt="cNoncopyableOwnedObject" shape="rect" coords="90,168,261,192">
<area href="classcOwnedObject.html" alt="cOwnedObject" shape="rect" coords="0,112,171,136">
<area href="classnoncopyable.html" alt="noncopyable" shape="rect" coords="181,112,352,136">
<area href="classcNamedObject.html" alt="cNamedObject" shape="rect" coords="0,56,171,80">
<area href="classcObject.html" alt="cObject" shape="rect" coords="0,0,171,24">
</map>
</div>

<p>
<a href="classcSimpleModule-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for all simple module classes. 
<p>
<a class="el" href="classcSimpleModule.html" title="Base class for all simple module classes.">cSimpleModule</a>, although packed with simulation-related functionality, does not do anything useful by itself: one has to subclass from it and redefine one or more virtual member functions to make it do useful work. These functions are:<p>
<ul>
<li>void <a class="el" href="classcComponent.html#0532af98c1157359b60adcb09f3fefca" title="Single-stage initialization hook.">initialize()</a></li><li>void <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage(cMessage *msg)</a></li><li>void <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a></li><li>void <a class="el" href="classcComponent.html#85912f961df471a9795d4e8454d9f6b0" title="Finish hook.">finish()</a></li></ul>
<p>
<a class="el" href="classcComponent.html#0532af98c1157359b60adcb09f3fefca" title="Single-stage initialization hook.">initialize()</a> is called after OMNeT++ created the module. Multi-stage initialization can be achieved by redefining the <a class="el" href="classcComponent.html#504f2d6eb1bcd03d3ef9809648e4988f" title="Multi-stage initialization hook.">initialize(int stage)</a> method instead, and also redefining the <a class="el" href="classcComponent.html#2d9bf75f1f04462929e85e10f5f4a24d" title="Multi-stage initialization hook, should be redefined to return the number of initialization...">numInitStages() const </a>method to return the required number of stages.<p>
One has to redefine <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a> to contain the internal logic of the module. <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a> is called by the simulation kernel when the module receives a message. (An alternative to <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a> is <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>, but <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a> is not recommended for serious model development because of scalability and debugging issues. <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a> also tends to lead to messy module implementations.)<p>
You can <a class="el" href="classcSimpleModule.html#94590ba6481116f29f4c43d00733deea" title="Sends a message through the gate given with its ID.">send()</a> messages to other modules, or use <a class="el" href="classcSimpleModule.html#29a64f1f0c560ac75494940d5c7a048d" title="Schedules a self-message.">scheduleAt()</a>+cancelEvent() to implement delays, timers or timeouts. Messages sent or scheduled (but not cancelled) are delivered to modules via <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a>, or, when using <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>, via <a class="el" href="classcSimpleModule.html#e67be4c6ee87a9b09129e81c866a2b1c" title="Remove the next message from the event queue and return a pointer to it.">receive()</a>.<p>
The <a class="el" href="classcComponent.html#85912f961df471a9795d4e8454d9f6b0" title="Finish hook.">finish()</a> functions are called when the simulation terminates successfully. Typical use of <a class="el" href="classcComponent.html#85912f961df471a9795d4e8454d9f6b0" title="Finish hook.">finish()</a> is recording statistics collected during simulation. <table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor, assignment.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#73cd49242b12142d1bcf9d8e44725d20">cSimpleModule</a> (unsigned stacksize=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#baf3c78d4204a86d97ab802b05777f33">cSimpleModule</a> (const char *dummy1, <a class="el" href="classcModule.html">cModule</a> *dummy2, unsigned stacksize)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#c71066adcba7babfa8fe6295032c1dcf">~cSimpleModule</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Redefined cObject member functions.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#1fbb4e8997b557f8e688284bda26ea48">info</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#e6c2cca1385f7e0cea5c5a100e4cfb69">forEachChild</a> (<a class="el" href="classcVisitor.html">cVisitor</a> *v)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Redefined cModule functions.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#da3fe83c75268f2cae40959d6b2dc64e">scheduleStart</a> (simtime_t t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#ed071be3b66c9a695b51bfebd19c5aa5">deleteModule</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Information about the module.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#cd1545693d0f3bdd452e2aa5cbe6ebcb">usesActivity</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#6a1f30ed927bb0060252d0be6d31f4f3">isTerminated</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Debugging aids.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#e9cce4496d6afc5ad01ef241a3320b93">snapshot</a> (<a class="el" href="classcObject.html">cObject</a> *obj=NULL, const char *label=NULL)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Message sending.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#94590ba6481116f29f4c43d00733deea">send</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, int gateid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#3066269a97c0585bff0f41c81bd5d095">send</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, const char *gatename, int gateindex=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#9e5da3f2aecf61604ad649dff3ab88f4">send</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, <a class="el" href="classcGate.html">cGate</a> *outputgate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#269f4b6e4e3e813e12f4a922d3047cf3">sendDelayed</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, simtime_t delay, int gateid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#d97aea478e65f9b1631f85fe0c9fe7b8">sendDelayed</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, simtime_t delay, const char *gatename, int gateindex=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#d9c3c6b96d644269f44c458504e684c4">sendDelayed</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, simtime_t delay, <a class="el" href="classcGate.html">cGate</a> *outputgate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#318262d2d5a58f7014fdb7c96d743dc4">sendDirect</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, <a class="el" href="classcModule.html">cModule</a> *mod, const char *inputGateName, int gateIndex=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#41b3f5b0dd21a8f4f138c3d4a978ed11">sendDirect</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, <a class="el" href="classcModule.html">cModule</a> *mod, int inputGateId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#4845c418bab12a4f74e70a0610f6aad0">sendDirect</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, <a class="el" href="classcGate.html">cGate</a> *inputGate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#dda3af3219c1e3db0211b4c67f4144fd">sendDirect</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration, <a class="el" href="classcModule.html">cModule</a> *mod, const char *inputGateName, int gateIndex=-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#c46b5a80045c85725af5b50498c1b98b">sendDirect</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration, <a class="el" href="classcModule.html">cModule</a> *mod, int inputGateId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#d1bbf6d313ffb7b1028c1e853e98ff35">sendDirect</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg, simtime_t propagationDelay, simtime_t duration, <a class="el" href="classcGate.html">cGate</a> *inputGate)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Self-messages.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#29a64f1f0c560ac75494940d5c7a048d">scheduleAt</a> (simtime_t t, <a class="el" href="classcMessage.html">cMessage</a> *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#c6dbd3f95eef46c010ab107f0eab3315">cancelEvent</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#59d46fbc9a77cb3e8164b0f624a51699">cancelAndDelete</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Receiving messages.</div></td></tr>
<tr><td colspan="2"><div class="groupText">These methods may only be invoked from activity()-based simple modules. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#e67be4c6ee87a9b09129e81c866a2b1c">receive</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#64c0ef9d9a844c062ed58d9837f281c0">receive</a> (simtime_t timeout)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Waiting.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#c049793c0ca1e6b73392d596e7f32e85">wait</a> (simtime_t time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#b6b2100ef4e33b2de7fa941b1d610375">waitAndEnqueue</a> (simtime_t time, <a class="el" href="classcQueue.html">cQueue</a> *queue)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Stopping the module or the simulation.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#8713bf9b4d4970fcfe94995dcb42ce9e">endSimulation</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#e6230498997a3c7e77301629b61d3199">halt</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#31fa5f75091ee137832ee6d2d714fb19">error</a> (const char *format,...) const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Coroutine stack info. Useful only if module uses activity().</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#8e3867232e08037e1794790150b4c0b4">hasStackOverflow</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#acc60dd6953b6002657efad300eadff7">getStackSize</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#848a48e638bb68dddbf2e178c863eac2">getStackUsage</a> () const </td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Hooks for defining module behavior.</div></td></tr>
<tr><td colspan="2"><div class="groupText">Exactly one of activity() and handleMessage() must be redefined by the user to add functionality to the simple module.<p>
See the manual for detailed guidance on how use to these two methods.<p>
These methods are made protected because they shouldn't be called directly from outside. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2">activity</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650">handleMessage</a> (<a class="el" href="classcMessage.html">cMessage</a> *msg)</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="37aa51760d5f85b54d00668308b926c8"></a><!-- doxytag: member="cSimpleModule::cModule" ref="37aa51760d5f85b54d00668308b926c8" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#37aa51760d5f85b54d00668308b926c8">cModule</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c6add72105ce0170138d90021da4d97"></a><!-- doxytag: member="cSimpleModule::cSimulation" ref="3c6add72105ce0170138d90021da4d97" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcSimpleModule.html#3c6add72105ce0170138d90021da4d97">cSimulation</a></td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="73cd49242b12142d1bcf9d8e44725d20"></a><!-- doxytag: member="cSimpleModule::cSimpleModule" ref="73cd49242b12142d1bcf9d8e44725d20" args="(unsigned stacksize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cSimpleModule::cSimpleModule           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>stacksize</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
Note that module objects should not be created directly, only via their <a class="el" href="classcModuleType.html" title="Abstract class for creating a module of a specific type.">cModuleType</a> objects. See <a class="el" href="classcModule.html" title="Common base for cSimpleModule and cCompoundModule.">cModule</a> constructor for more info. The stacksize parameter should only be used with simple modules using <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>. 
</div>
</div><p>
<a class="anchor" name="baf3c78d4204a86d97ab802b05777f33"></a><!-- doxytag: member="cSimpleModule::cSimpleModule" ref="baf3c78d4204a86d97ab802b05777f33" args="(const char *dummy1, cModule *dummy2, unsigned stacksize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cSimpleModule::cSimpleModule           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>dummy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>dummy2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>stacksize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
COMPATIBILITY. 
<p>
This constructor is only provided to make it possible to write simple modules that do not use the Module_Class_Members macro and can also be compiled with OMNeT++ versions earlier than 3.2. The first two args are unused in this and later versions. 
</div>
</div><p>
<a class="anchor" name="c71066adcba7babfa8fe6295032c1dcf"></a><!-- doxytag: member="cSimpleModule::~cSimpleModule" ref="c71066adcba7babfa8fe6295032c1dcf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual cSimpleModule::~cSimpleModule           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e7367768a6ad61a0e2256635e1ef6de2"></a><!-- doxytag: member="cSimpleModule::activity" ref="e7367768a6ad61a0e2256635e1ef6de2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cSimpleModule::activity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Should be redefined to contain the module activity function. 
<p>
For several good reasons, you should prefer <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a> to <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>. This default implementation issues an error message (throws <a class="el" href="classcRuntimeError.html" title="Thrown when the simulation kernel or other components detect a runtime error.">cRuntimeError</a>). 
</div>
</div><p>
<a class="anchor" name="c1a639fd9b931de297477fca26341650"></a><!-- doxytag: member="cSimpleModule::handleMessage" ref="c1a639fd9b931de297477fca26341650" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cSimpleModule::handleMessage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Should be redefined to contain the module's message handling function. 
<p>
This default implementation issues an error message (throws <a class="el" href="classcRuntimeError.html" title="Thrown when the simulation kernel or other components detect a runtime error.">cRuntimeError</a>). 
</div>
</div><p>
<a class="anchor" name="1fbb4e8997b557f8e688284bda26ea48"></a><!-- doxytag: member="cSimpleModule::info" ref="1fbb4e8997b557f8e688284bda26ea48" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cSimpleModule::info           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Produces a one-line description of the object's contents. 
<p>
See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. 
<p>Reimplemented from <a class="el" href="classcDefaultList.html#5e4a58b629cfdd7e238fb87615c0bd06">cDefaultList</a>.</p>

</div>
</div><p>
<a class="anchor" name="e6c2cca1385f7e0cea5c5a100e4cfb69"></a><!-- doxytag: member="cSimpleModule::forEachChild" ref="e6c2cca1385f7e0cea5c5a100e4cfb69" args="(cVisitor *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cSimpleModule::forEachChild           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcVisitor.html">cVisitor</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls v-&gt;visit(this) for each contained object. 
<p>
See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. 
<p>Reimplemented from <a class="el" href="classcModule.html#091296dfd37373944cb1532b5c11dd87">cModule</a>.</p>

</div>
</div><p>
<a class="anchor" name="da3fe83c75268f2cae40959d6b2dc64e"></a><!-- doxytag: member="cSimpleModule::scheduleStart" ref="da3fe83c75268f2cae40959d6b2dc64e" args="(simtime_t t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cSimpleModule::scheduleStart           </td>
          <td>(</td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a starting message for the module. 
<p>

<p>Implements <a class="el" href="classcModule.html#aaed82aec8392c256d984b7975384d0c">cModule</a>.</p>

</div>
</div><p>
<a class="anchor" name="ed071be3b66c9a695b51bfebd19c5aa5"></a><!-- doxytag: member="cSimpleModule::deleteModule" ref="ed071be3b66c9a695b51bfebd19c5aa5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cSimpleModule::deleteModule           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the module and all its (dynamically created) submodules. 
<p>
A running module can also delete itself. When an <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>-based simple module deletes itself from within its <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>, the <a class="el" href="classcSimpleModule.html#ed071be3b66c9a695b51bfebd19c5aa5" title="Deletes the module and all its (dynamically created) submodules.">deleteModule()</a> call will not return (it throws an exception which gets caught by the simulation kernel, and the simulation kernel will delete the module).<p>
When a <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a>-based module deletes itself, the <a class="el" href="classcSimpleModule.html#ed071be3b66c9a695b51bfebd19c5aa5" title="Deletes the module and all its (dynamically created) submodules.">deleteModule()</a> returns normally -- then, of course, the code should not try to access data members or functions of the deleted module, an should return as soon as possible. 
<p>Reimplemented from <a class="el" href="classcModule.html#a40e04f3a15395bfad553227c0a51866">cModule</a>.</p>

</div>
</div><p>
<a class="anchor" name="cd1545693d0f3bdd452e2aa5cbe6ebcb"></a><!-- doxytag: member="cSimpleModule::usesActivity" ref="cd1545693d0f3bdd452e2aa5cbe6ebcb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cSimpleModule::usesActivity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the event handling scheme: <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a> or <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="6a1f30ed927bb0060252d0be6d31f4f3"></a><!-- doxytag: member="cSimpleModule::isTerminated" ref="6a1f30ed927bb0060252d0be6d31f4f3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cSimpleModule::isTerminated           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the module has already terminated, by having called end() or returning from the <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a> method. 
<p>

</div>
</div><p>
<a class="anchor" name="e9cce4496d6afc5ad01ef241a3320b93"></a><!-- doxytag: member="cSimpleModule::snapshot" ref="e9cce4496d6afc5ad01ef241a3320b93" args="(cObject *obj=NULL, const char *label=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cSimpleModule::snapshot           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcObject.html">cObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>label</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To be called from module functions. 
<p>
Outputs textual information about all objects of the simulation (including the objects created in module functions by the user!) into the snapshot file. The output is detailed enough to be used for debugging the simulation: by regularly calling <a class="el" href="classcSimpleModule.html#e9cce4496d6afc5ad01ef241a3320b93" title="To be called from module functions.">snapshot()</a>, one can trace how the values of variables, objects changed over the simulation. The arguments: label is a string that will appear in the output file; obj is the object whose inside is of interest. By default, the whole simulation (all modules etc) will be written out.<p>
Tkenv also supports making snapshots manually, from menu.<p>
See also class cWatch and the <a class="el" href="group__MacrosWatch.html#g0878b62c3a2dcb0388c967a4acb2f18a" title="Makes primitive types and types with operator&lt;&lt; inspectable in Tkenv.">WATCH()</a> macro. 
</div>
</div><p>
<a class="anchor" name="94590ba6481116f29f4c43d00733deea"></a><!-- doxytag: member="cSimpleModule::send" ref="94590ba6481116f29f4c43d00733deea" args="(cMessage *msg, int gateid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::send           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gateid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message through the gate given with its ID. 
<p>

</div>
</div><p>
<a class="anchor" name="3066269a97c0585bff0f41c81bd5d095"></a><!-- doxytag: member="cSimpleModule::send" ref="3066269a97c0585bff0f41c81bd5d095" args="(cMessage *msg, const char *gatename, int gateindex=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::send           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gateindex</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message through the gate given with its name and index (if multiple gate). 
<p>

</div>
</div><p>
<a class="anchor" name="9e5da3f2aecf61604ad649dff3ab88f4"></a><!-- doxytag: member="cSimpleModule::send" ref="9e5da3f2aecf61604ad649dff3ab88f4" args="(cMessage *msg, cGate *outputgate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::send           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html">cGate</a> *&nbsp;</td>
          <td class="paramname"> <em>outputgate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message through the gate given with its pointer. 
<p>

</div>
</div><p>
<a class="anchor" name="269f4b6e4e3e813e12f4a922d3047cf3"></a><!-- doxytag: member="cSimpleModule::sendDelayed" ref="269f4b6e4e3e813e12f4a922d3047cf3" args="(cMessage *msg, simtime_t delay, int gateid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDelayed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gateid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delayed sending. 
<p>
Sends a message through the gate given with its index as if it was sent delay seconds later. 
</div>
</div><p>
<a class="anchor" name="d97aea478e65f9b1631f85fe0c9fe7b8"></a><!-- doxytag: member="cSimpleModule::sendDelayed" ref="d97aea478e65f9b1631f85fe0c9fe7b8" args="(cMessage *msg, simtime_t delay, const char *gatename, int gateindex=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDelayed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>gatename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gateindex</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delayed sending. 
<p>
Sends a message through the gate given with its name and index (if multiple gate) as if it was sent delay seconds later. 
</div>
</div><p>
<a class="anchor" name="d9c3c6b96d644269f44c458504e684c4"></a><!-- doxytag: member="cSimpleModule::sendDelayed" ref="d9c3c6b96d644269f44c458504e684c4" args="(cMessage *msg, simtime_t delay, cGate *outputgate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDelayed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html">cGate</a> *&nbsp;</td>
          <td class="paramname"> <em>outputgate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message through the gate given with its pointer as if it was sent delay seconds later. 
<p>

</div>
</div><p>
<a class="anchor" name="318262d2d5a58f7014fdb7c96d743dc4"></a><!-- doxytag: member="cSimpleModule::sendDirect" ref="318262d2d5a58f7014fdb7c96d743dc4" args="(cMessage *msg, cModule *mod, const char *inputGateName, int gateIndex=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDirect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inputGateName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gateIndex</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message directly to another module, with zero propagation delay and duration. 
<p>
See <a class="el" href="classcSimpleModule.html#d1bbf6d313ffb7b1028c1e853e98ff35" title="Send a message directly to another module.">sendDirect(cMessage *, simtime_t, simtime_t, cGate *)</a> for a more detailed description. 
</div>
</div><p>
<a class="anchor" name="41b3f5b0dd21a8f4f138c3d4a978ed11"></a><!-- doxytag: member="cSimpleModule::sendDirect" ref="41b3f5b0dd21a8f4f138c3d4a978ed11" args="(cMessage *msg, cModule *mod, int inputGateId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDirect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>inputGateId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message directly to another module, with zero propagation delay and duration. 
<p>
See <a class="el" href="classcSimpleModule.html#d1bbf6d313ffb7b1028c1e853e98ff35" title="Send a message directly to another module.">sendDirect(cMessage *, simtime_t, simtime_t, cGate *)</a> for a more detailed description. 
</div>
</div><p>
<a class="anchor" name="4845c418bab12a4f74e70a0610f6aad0"></a><!-- doxytag: member="cSimpleModule::sendDirect" ref="4845c418bab12a4f74e70a0610f6aad0" args="(cMessage *msg, cGate *inputGate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDirect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html">cGate</a> *&nbsp;</td>
          <td class="paramname"> <em>inputGate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message directly to another module, with zero propagation delay and duration. 
<p>
See <a class="el" href="classcSimpleModule.html#d1bbf6d313ffb7b1028c1e853e98ff35" title="Send a message directly to another module.">sendDirect(cMessage *, simtime_t, simtime_t, cGate *)</a> for a more detailed description. 
</div>
</div><p>
<a class="anchor" name="dda3af3219c1e3db0211b4c67f4144fd"></a><!-- doxytag: member="cSimpleModule::sendDirect" ref="dda3af3219c1e3db0211b4c67f4144fd" args="(cMessage *msg, simtime_t propagationDelay, simtime_t duration, cModule *mod, const char *inputGateName, int gateIndex=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDirect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>propagationDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inputGateName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>gateIndex</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a message directly to another module. 
<p>
See <a class="el" href="classcSimpleModule.html#d1bbf6d313ffb7b1028c1e853e98ff35" title="Send a message directly to another module.">sendDirect(cMessage *, simtime_t, simtime_t, cGate *)</a> for a more detailed description. 
</div>
</div><p>
<a class="anchor" name="c46b5a80045c85725af5b50498c1b98b"></a><!-- doxytag: member="cSimpleModule::sendDirect" ref="c46b5a80045c85725af5b50498c1b98b" args="(cMessage *msg, simtime_t propagationDelay, simtime_t duration, cModule *mod, int inputGateId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDirect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>propagationDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcModule.html">cModule</a> *&nbsp;</td>
          <td class="paramname"> <em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>inputGateId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See <a class="el" href="classcSimpleModule.html#d1bbf6d313ffb7b1028c1e853e98ff35" title="Send a message directly to another module.">sendDirect(cMessage *, simtime_t, simtime_t, cGate *)</a> for a more detailed description. 
<p>

</div>
</div><p>
<a class="anchor" name="d1bbf6d313ffb7b1028c1e853e98ff35"></a><!-- doxytag: member="cSimpleModule::sendDirect" ref="d1bbf6d313ffb7b1028c1e853e98ff35" args="(cMessage *msg, simtime_t propagationDelay, simtime_t duration, cGate *inputGate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::sendDirect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>propagationDelay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcGate.html">cGate</a> *&nbsp;</td>
          <td class="paramname"> <em>inputGate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message directly to another module. 
<p>
If the target gate is further connected (i.e. getNextGate()!=NULL), the message will follow the connections that start at that gate. For example, when sending to an input gate of a compound module, the message will follow the connections inside the compound module.<p>
It is permitted to send to an output gate, which will also cause the message to follow the connections starting at that gate. This can be useful, for example, when several submodules are sending to a single output gate of their parent module.<p>
It is not permitted to send to a gate of a compound module which is not further connected (i.e. getNextGate()==NULL), as this would cause the message to arrive at a compound module.<p>
Also, it is not permitted to send to a gate which is otherwise connected i.e. where getPreviousGate()!=NULL. This means that modules MUST have dedicated gates for receiving via <a class="el" href="classcSimpleModule.html#318262d2d5a58f7014fdb7c96d743dc4" title="Sends a message directly to another module, with zero propagation delay and duration...">sendDirect()</a>. You cannot have a gate which receives messages via both connections and <a class="el" href="classcSimpleModule.html#318262d2d5a58f7014fdb7c96d743dc4" title="Sends a message directly to another module, with zero propagation delay and duration...">sendDirect()</a>.<p>
When a nonzero duration is given, that signifies the duration of the packet transmission, that is, the time difference between the transmission (or reception) of the start of the packet and that of the end of the packet. The destination module can choose whether it wants the simulation kernel to deliver the packet object to it at the start or at the end of the reception. The default is the latter; the module can change it by calling setDeliverOnReceptionStart() on the final input gate (that is, on inputGate-&gt;getPathEndGate()). setDeliverOnReceptionStart() needs to be called in advance, for example in the <a class="el" href="classcComponent.html#0532af98c1157359b60adcb09f3fefca" title="Single-stage initialization hook.">initialize()</a> method of the module. When a module receives a packet, it can call the isReceptionStart() and getDuration() methods on the packet to find out whether it represents the start or the end of the reception, and the duration of the transmission.<p>
For messages that are not packets (i.e. not subclassed from <a class="el" href="classcPacket.html" title="A subclass of cMessage that can be used to represent packets (frames, datagrams,...">cPacket</a>), the duration parameter must be zero. 
</div>
</div><p>
<a class="anchor" name="29a64f1f0c560ac75494940d5c7a048d"></a><!-- doxytag: member="cSimpleModule::scheduleAt" ref="29a64f1f0c560ac75494940d5c7a048d" args="(simtime_t t, cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cSimpleModule::scheduleAt           </td>
          <td>(</td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Schedules a self-message. 
<p>
It will be delivered back to the module via <a class="el" href="classcSimpleModule.html#e67be4c6ee87a9b09129e81c866a2b1c" title="Remove the next message from the event queue and return a pointer to it.">receive()</a> or <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a> at simulation time t. This method is the way you can implement timers or timeouts. Timers can also be cancelled via <a class="el" href="classcSimpleModule.html#c6dbd3f95eef46c010ab107f0eab3315" title="Removes the given message from the future events.">cancelEvent()</a> (See below.)<p>
When the message is delivered at the module, you can call <code>msg-&gt;isSelfMessage()</code> to tell it apart from messages arriving from other modules. <code>msg-&gt;getKind()</code> can be used to further classify it, or of you need to manage an unbounded number of timers, you can set <code>msg-&gt;getContextPointer()</code> before scheduling to point to the data structure the message belongs to -- this way you can avoid having to search through lists or other data structures to find out where a just-arrived self-message belongs.<p>
<a class="el" href="classcSimpleModule.html#c6dbd3f95eef46c010ab107f0eab3315" title="Removes the given message from the future events.">cancelEvent()</a> can be used to cancel the self-message before it arrives. This is useful for implementing timeouts: if the event occurs "in time" (before timeout), the scheduled self-message can be cancelled.<p>
Given a <a class="el" href="classcMessage.html" title="The message class in OMNeT++.">cMessage</a> pointer, you can check whether it is currently scheduled by calling <code>msg-&gt;isScheduled()</code>. If it is scheduled, you cannot schedule it again without calling <a class="el" href="classcSimpleModule.html#c6dbd3f95eef46c010ab107f0eab3315" title="Removes the given message from the future events.">cancelEvent()</a> first. However, after the message was delivered to the module or cancelled, you can schedule it again -- so you can reuse the same message object for timeouts over and over during the whole simulation. 
</div>
</div><p>
<a class="anchor" name="c6dbd3f95eef46c010ab107f0eab3315"></a><!-- doxytag: member="cSimpleModule::cancelEvent" ref="c6dbd3f95eef46c010ab107f0eab3315" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcMessage.html">cMessage</a>* cSimpleModule::cancelEvent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the given message from the future events. 
<p>
The message needs to have been sent using the <a class="el" href="classcSimpleModule.html#29a64f1f0c560ac75494940d5c7a048d" title="Schedules a self-message.">scheduleAt()</a> function. This function can be used to cancel a timer implemented with <a class="el" href="classcSimpleModule.html#29a64f1f0c560ac75494940d5c7a048d" title="Schedules a self-message.">scheduleAt()</a>. If the message is not currently scheduled, nothing happens. 
</div>
</div><p>
<a class="anchor" name="59d46fbc9a77cb3e8164b0f624a51699"></a><!-- doxytag: member="cSimpleModule::cancelAndDelete" ref="59d46fbc9a77cb3e8164b0f624a51699" args="(cMessage *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSimpleModule::cancelAndDelete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcMessage.html">cMessage</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invokes <a class="el" href="classcSimpleModule.html#c6dbd3f95eef46c010ab107f0eab3315" title="Removes the given message from the future events.">cancelEvent()</a> on the message (in case it is scheduled), then deletes it. 
<p>
A NULL pointer is also accepted, then the method does nothing. This method is especially useful in simple module destructors, to dispose of self-messages that the module has allocated. 
</div>
</div><p>
<a class="anchor" name="e67be4c6ee87a9b09129e81c866a2b1c"></a><!-- doxytag: member="cSimpleModule::receive" ref="e67be4c6ee87a9b09129e81c866a2b1c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcMessage.html">cMessage</a>* cSimpleModule::receive           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the next message from the event queue and return a pointer to it. 
<p>

</div>
</div><p>
<a class="anchor" name="64c0ef9d9a844c062ed58d9837f281c0"></a><!-- doxytag: member="cSimpleModule::receive" ref="64c0ef9d9a844c062ed58d9837f281c0" args="(simtime_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcMessage.html">cMessage</a>* cSimpleModule::receive           </td>
          <td>(</td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the next message from the event queue and returns a pointer to it. 
<p>
If there is no message in the event queue, the function waits with t timeout until a message will be available. If the timeout expires and there is still no message in the queue, the function returns NULL. 
</div>
</div><p>
<a class="anchor" name="c049793c0ca1e6b73392d596e7f32e85"></a><!-- doxytag: member="cSimpleModule::wait" ref="c049793c0ca1e6b73392d596e7f32e85" args="(simtime_t time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSimpleModule::wait           </td>
          <td>(</td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>time</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits for the given interval. 
<p>
(Some other simulators call this functionality hold()). It is intended for use only if you do not expect other messages to arrive at the module during the wait period. To assert this, it throws an exception if a message arrives during the wait.<p>
If you expect to receive messages during the call, you should use <a class="el" href="classcSimpleModule.html#b6b2100ef4e33b2de7fa941b1d610375" title="Waits for the given interval.">waitAndEnqueue()</a> instead.<p>
This function can only be used with <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>, but not with <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a>. 
</div>
</div><p>
<a class="anchor" name="b6b2100ef4e33b2de7fa941b1d610375"></a><!-- doxytag: member="cSimpleModule::waitAndEnqueue" ref="b6b2100ef4e33b2de7fa941b1d610375" args="(simtime_t time, cQueue *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSimpleModule::waitAndEnqueue           </td>
          <td>(</td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcQueue.html">cQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits for the given interval. 
<p>
The messages received during the wait period are inserted into the queue passed as argument.<p>
This function can only be used with <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>, but not with <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a>. 
</div>
</div><p>
<a class="anchor" name="8713bf9b4d4970fcfe94995dcb42ce9e"></a><!-- doxytag: member="cSimpleModule::endSimulation" ref="8713bf9b4d4970fcfe94995dcb42ce9e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSimpleModule::endSimulation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Causes the whole simulation to stop. 
<p>
The implementation simply throws a <a class="el" href="classcTerminationException.html" title="Thrown when the simulation is completed.">cTerminationException</a>. 
</div>
</div><p>
<a class="anchor" name="e6230498997a3c7e77301629b61d3199"></a><!-- doxytag: member="cSimpleModule::halt" ref="e6230498997a3c7e77301629b61d3199" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSimpleModule::halt           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
May only be invoked from <a class="el" href="classcSimpleModule.html#e7367768a6ad61a0e2256635e1ef6de2" title="Should be redefined to contain the module activity function.">activity()</a>-based simple modules. 
<p>
Execution of the simple module stops in this call, and any further messages sent to module will cause a runtime error. 
</div>
</div><p>
<a class="anchor" name="31fa5f75091ee137832ee6d2d714fb19"></a><!-- doxytag: member="cSimpleModule::error" ref="31fa5f75091ee137832ee6d2d714fb19" args="(const char *format,...) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cSimpleModule::error           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to <code>throw <a class="el" href="classcRuntimeError.html" title="Thrown when the simulation kernel or other components detect a runtime error.">cRuntimeError</a>(<em>same argument list</em>)</code>. 
<p>

</div>
</div><p>
<a class="anchor" name="8e3867232e08037e1794790150b4c0b4"></a><!-- doxytag: member="cSimpleModule::hasStackOverflow" ref="8e3867232e08037e1794790150b4c0b4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cSimpleModule::hasStackOverflow           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if there was a stack overflow during execution of the coroutine. 
<p>
(Not implemented for every coroutine package - see <a class="el" href="classcCoroutine.html" title="Low-level coroutine library.">cCoroutine</a> documentation for more info.) If the module uses <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a>, this method always returns false.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcCoroutine.html" title="Low-level coroutine library.">cCoroutine</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="acc60dd6953b6002657efad300eadff7"></a><!-- doxytag: member="cSimpleModule::getStackSize" ref="acc60dd6953b6002657efad300eadff7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned cSimpleModule::getStackSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the stack size of the coroutine. 
<p>
If the module uses <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a>, this method always returns 0. 
</div>
</div><p>
<a class="anchor" name="848a48e638bb68dddbf2e178c863eac2"></a><!-- doxytag: member="cSimpleModule::getStackUsage" ref="848a48e638bb68dddbf2e178c863eac2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned cSimpleModule::getStackUsage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the amount of stack actually used by the coroutine. 
<p>
(Not implemented for every coroutine package - see <a class="el" href="classcCoroutine.html" title="Low-level coroutine library.">cCoroutine</a> documentation for more info.) If the module uses <a class="el" href="classcSimpleModule.html#c1a639fd9b931de297477fca26341650" title="Should be redefined to contain the module&#39;s message handling function.">handleMessage()</a>, this method always returns 0.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcCoroutine.html" title="Low-level coroutine library.">cCoroutine</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="csimplemodule_8h-source.html">csimplemodule.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Mar 27 11:22:13 2012 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
